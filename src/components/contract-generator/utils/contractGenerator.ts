import { ContractSettings } from '../types/interfaces';
import { NETWORK_OPTIONS, CONTRACT_TYPES } from '../types/constants';

export const generateContractCode = (settings: ContractSettings): string => {
  const contractName = settings.tokenName.replace(/\s+/g, '');
  const network = NETWORK_OPTIONS.find(n => n.id === settings.networkId);
  const contractTypeInfo = CONTRACT_TYPES.find(t => t.id === settings.contractType);
  
  const contractCode = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
${settings.securityFeatures.pausable ? 'import "@openzeppelin/contracts/utils/Pausable.sol";' : ''}
${settings.securityFeatures.burnable ? 'import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";' : ''}

/**
 * @title ${contractName}
 * @dev ${contractTypeInfo?.description || 'Custom token contract'}
 * @notice Generated by PulseChain Genesis Forge
 * 
 * Features:
${contractTypeInfo?.features.map(f => ` * - ${f}`).join('\n') || ''}
 * 
 * Network: ${network?.name || 'Custom Network'}
 * Total Supply: ${settings.totalSupply} ${settings.tokenSymbol}
 * Decimals: ${settings.decimals}
 */
contract ${contractName} is ERC20, Ownable${settings.securityFeatures.pausable ? ', Pausable' : ''}${settings.securityFeatures.burnable ? ', ERC20Burnable' : ''} {
    
    uint256 private constant TOTAL_SUPPLY = ${settings.totalSupply} * 10**${settings.decimals};
    ${settings.contractType === 'tax' || settings.contractType === 'meme-advanced' ? `
    // Tax Configuration
    uint256 public buyTax = ${settings.taxSettings.buyTax};
    uint256 public sellTax = ${settings.taxSettings.sellTax};
    uint256 public transferTax = ${settings.taxSettings.transferTax};
    
    // Trading Settings
    bool public tradingEnabled = false;
    bool public limitsInEffect = true;
    
    // Wallets
    address public marketingWallet;
    address public devWallet;
    
    // DEX Configuration
    address public immutable dexRouter = ${network?.routerAddress || '0x165C3410fC91EF562C50559f7d2289fEbed552d9'};
    address public dexPair;
    
    // Security Mappings
    mapping(address => bool) private _isExcludedFromFees;
    mapping(address => bool) private _isExcludedFromLimits;
    ${settings.securityFeatures.blacklist ? 'mapping(address => bool) private _blacklist;' : ''}
    
    // Events
    event TradingEnabled(uint256 timestamp);
    event TaxesUpdated(uint256 buyTax, uint256 sellTax, uint256 transferTax);
    event WalletUpdated(string walletType, address oldWallet, address newWallet);
    ${settings.securityFeatures.blacklist ? 'event AddressBlacklisted(address indexed account, bool isBlacklisted);' : ''}` : ''}
    
    constructor() ERC20("${settings.tokenName}", "${settings.tokenSymbol}") Ownable(_msgSender()) {
        _mint(_msgSender(), TOTAL_SUPPLY);
        
        ${settings.contractType === 'tax' || settings.contractType === 'meme-advanced' ? `
        // Exclude owner and contract from fees
        _isExcludedFromFees[_msgSender()] = true;
        _isExcludedFromFees[address(this)] = true;
        
        _isExcludedFromLimits[_msgSender()] = true;
        _isExcludedFromLimits[address(this)] = true;` : ''}
    }
    
    ${settings.contractType === 'tax' || settings.contractType === 'meme-advanced' ? `
    // Owner Functions
    function enableTrading() external onlyOwner {
        require(!tradingEnabled, "Trading already enabled");
        tradingEnabled = true;
        emit TradingEnabled(block.timestamp);
    }
    
    function updateTaxes(uint256 _buyTax, uint256 _sellTax, uint256 _transferTax) external onlyOwner {
        require(_buyTax <= 25 && _sellTax <= 25 && _transferTax <= 25, "Tax too high");
        buyTax = _buyTax;
        sellTax = _sellTax;
        transferTax = _transferTax;
        emit TaxesUpdated(_buyTax, _sellTax, _transferTax);
    }
    
    function setWallets(address _marketingWallet, address _devWallet) external onlyOwner {
        require(_marketingWallet != address(0) && _devWallet != address(0), "Invalid wallet");
        marketingWallet = _marketingWallet;
        devWallet = _devWallet;
    }
    
    function excludeFromFees(address account, bool excluded) external onlyOwner {
        _isExcludedFromFees[account] = excluded;
    }
    
    ${settings.securityFeatures.blacklist ? `
    function setBlacklist(address account, bool blacklisted) external onlyOwner {
        require(account != owner(), "Cannot blacklist owner");
        _blacklist[account] = blacklisted;
        emit AddressBlacklisted(account, blacklisted);
    }` : ''}
    
    // View Functions
    function isExcludedFromFees(address account) public view returns (bool) {
        return _isExcludedFromFees[account];
    }
    
    ${settings.securityFeatures.blacklist ? `
    function isBlacklisted(address account) public view returns (bool) {
        return _blacklist[account];
    }` : ''}` : ''}
    
    ${settings.securityFeatures.pausable ? `
    // Emergency Functions
    function emergencyPause() external onlyOwner {
        _pause();
    }
    
    function emergencyUnpause() external onlyOwner {
        _unpause();
    }` : ''}
    
    // Emergency withdrawal
    function emergencyWithdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
    
    ${settings.contractType === 'tax' || settings.contractType === 'meme-advanced' ? `
    // Override transfer function for tax implementation
    function _update(address from, address to, uint256 amount) internal override ${settings.securityFeatures.pausable ? 'whenNotPaused ' : ''} {
        // Skip checks for minting/burning
        if (from == address(0) || to == address(0)) {
            super._update(from, to, amount);
            return;
        }
        
        require(amount > 0, "Transfer amount must be greater than zero");
        require(tradingEnabled || _isExcludedFromFees[from], "Trading not enabled");
        
        ${settings.securityFeatures.blacklist ? `
        require(!_blacklist[from], "Sender is blacklisted");
        require(!_blacklist[to], "Recipient is blacklisted");` : ''}
        
        // Calculate tax
        uint256 taxAmount = 0;
        if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {
            if (to == dexPair) {
                // Sell transaction
                taxAmount = (amount * sellTax) / 100;
            } else if (from == dexPair) {
                // Buy transaction
                taxAmount = (amount * buyTax) / 100;
            } else {
                // Transfer transaction
                taxAmount = (amount * transferTax) / 100;
            }
        }
        
        uint256 transferAmount = amount - taxAmount;
        
        if (taxAmount > 0) {
            super._update(from, address(this), taxAmount);
        }
        
        super._update(from, to, transferAmount);
    }
    
    // Swap and liquify functions would go here...
    // This is a simplified version for demonstration` : ''}
    
    ${settings.securityFeatures.reflection ? `
    // Reflection mechanism implementation would go here
    // This requires complex dividend distribution logic` : ''}
    
    ${settings.securityFeatures.deflationary ? `
    // Deflationary burn on transfer
    function _burnOnTransfer(uint256 amount) private {
        uint256 burnAmount = (amount * 1) / 100; // 1% burn
        if (burnAmount > 0) {
            _burn(address(this), burnAmount);
        }
    }` : ''}
    
    // Receive function to accept ETH
    receive() external payable {}
}

// Additional contracts for advanced features would be deployed separately:
// - Dividend Tracker for reflection tokens
// - Liquidity Lock contract
// - DAO Governance contracts
// - Staking contract for utility tokens

/**
 * @notice Deployment Instructions:
 * 1. Deploy this contract on ${network?.name || 'your chosen network'}
 * 2. Verify the contract on ${network?.blockExplorer || 'block explorer'}
 * 3. Create liquidity pair on DEX
 * 4. Set up tax wallets and enable trading
 * 5. Lock liquidity for security
 * 
 * @dev Security Checklist:
 * - ✓ Ownership is properly initialized
 * - ✓ Tax limits are enforced (max 25%)
 * - ✓ Emergency functions are protected
 * - ✓ Anti-whale protection if enabled
 * - ✓ Blacklist function if enabled
 * 
 * Remember to:
 * - Test thoroughly on testnet first
 * - Set reasonable tax rates
 * - Configure all wallets before launch
 * - Enable trading only when ready
 */`;

  return contractCode;
};

export const generateDeploymentInstructions = (settings: ContractSettings): string => {
  const network = NETWORK_OPTIONS.find(n => n.id === settings.networkId);
  
  return `# Deployment Instructions for ${settings.tokenName}

## Prerequisites
- MetaMask or compatible wallet
- ${network?.symbol || 'Network tokens'} for gas fees
- Remix IDE or Hardhat for deployment

## Step-by-Step Deployment

### 1. Prepare Environment
- Switch to ${network?.name || 'target network'}
- Ensure sufficient ${network?.symbol || 'gas tokens'} for deployment
- Have router address ready: ${network?.routerAddress || 'N/A'}

### 2. Deploy Contract
- Copy the generated contract code
- Compile in Remix or your preferred environment
- Deploy with proper constructor parameters

### 3. Initial Setup
${settings.contractType === 'tax' || settings.contractType === 'meme-advanced' ? `
- Set marketing wallet: ${settings.walletSettings.marketingWallet || 'Set after deployment'}
- Set dev wallet: ${settings.walletSettings.devWallet || 'Set after deployment'}
- Configure tax rates (currently: Buy ${settings.taxSettings.buyTax}%, Sell ${settings.taxSettings.sellTax}%)
` : ''}

### 4. Create Liquidity
- Add initial liquidity on DEX
- Lock liquidity for security
- Set trading limits if applicable

### 5. Enable Trading
${settings.contractType === 'tax' || settings.contractType === 'meme-advanced' ? `
- Call enableTrading() function
- Monitor first transactions
- Adjust settings if needed
` : ''}

## Security Recommendations
- Test on testnet first
- Verify contract source code
- Use multi-sig for important functions
- Monitor for unusual activity

## Gas Estimates
- Deployment: ~${CONTRACT_TYPES.find(t => t.id === settings.contractType)?.gasEstimate || '2M gas'}
- Enable Trading: ~50k gas
- Tax Updates: ~30k gas
`;
};
